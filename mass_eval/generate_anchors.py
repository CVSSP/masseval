import numpy as np
from untwist import (data, utilities, transforms, analysis)
from collections import namedtuple


Anchors = namedtuple('Anchors', ['Distortion',
                                 'Artefacts',
                                 'Interferer',
                                 'Quality'],
                     )


class Anchor:
    '''
    Anchor signals for a MUSHRA test assessing source separation
    techniques.  Four different anchors are provided for assessing the
    perception regarding interference, distortion, artefacts, and
    overall sound quality.  The first three were designed after [1], the
    quality anchor after [2].

    [1] Emiya, V., Vincent, E., Harlander, N., & Hohmann, V. (2011).
        Subjective and Objective Quality Assessment of Audio Source
        Separation. IEEE TASLP, 19(7), 2046–2057.
        http://doi.org/10.1109/TASL.2011.2109381
    [2] Cano, E., Fitzgerald, D., & Brandenburg, K. (2016).
        Evaluation of Quality of Sound Source Separation Algorithms:
        Human Perception vs Quantitative Metrics. In EUSIPCO
        (pp. 1758–1762).
        http://doi.org/10.1109/EUSIPCO.2016.7760550
    '''

    def __init__(self, target, others):
        from scipy import signal

        self.target = target
        self.others = others

        points = 2048
        window = signal.get_window('hann', points, True)
        self.stft = transforms.STFT(window, points, points // 2)
        self.istft = transforms.ISTFT(window, points, points // 2)

        self.cut_off = utilities.conversion.nearest_bin(3500,
                                                        points,
                                                        target.sample_rate)
        self.trim_factor_distorted = 0.2
        self.trim_factor_artefacts = 0.99

        self.ebur128 = analysis.loudness.EBUR128(
            sample_rate=target.sample_rate)

    def distorted_anchor(self):
        '''
        Distortion anchor for a MUSHRA listening test.
        The anchor is created by low-pass filtering the target source
        signal to a 3.5 kHz cutoff frequency and by randomly setting 20%
        of the remaining time-frequency coefficients to zero, see [1].

        WARNING: this code can't reproduce the distortion anchor from
        [1] exactly!
        '''

        x_fft = self.stft.process(self.target)

        x_fft[self.cut_off:] = 0

        num_frames_to_remove = int(x_fft.shape[1] * self.trim_factor_distorted)
        idx = np.random.choice(x_fft.shape[1],
                               num_frames_to_remove,
                               replace=False)
        x_fft[:, idx] = 0

        anchor = self.istft.process(x_fft)
        anchor = anchor[:self.target.num_frames]

        return anchor.normalize()

    def interferer(self):
        '''
        Returns the interfering signal generated by summing all others
        signals with the same loudness.
        '''

        # set all interferences to have the same loudness
        target_loudness = -23

        interferers = []

        for i, other in enumerate(self.others):

            other_loudness = self.ebur128.process(other).P

            other *= utilities.conversion.db_to_amp(
                target_loudness - other_loudness)

            interferers.append(other)

        return sum(interferers)

    def inteference_anchor(self):
        '''
        Interference anchor for a MUSHRA listening test.
        The anchor is created by the sum of target signal and the
        interferer. The interferer is formed by summing all interfering
        sources. Here, all interfering sources are set equally loud, and
        then setting the overall loudness to that of the target, see
        [1].
        '''

        interferer = self.interferer()

        # Now match the loudness of the global interferer to that of the target
        target_loudness = self.ebur128.process(self.target).P

        interferer_loudness = self.ebur128.process(interferer).P

        interferer *= utilities.conversion.db_to_amp(
            target_loudness - interferer_loudness)

        interferer += self.target

        return interferer.normalize()

    def artefacts(self):
        '''
        Returns the artefacts signal generated by randomly zeroing 99%
        of the time-frequency bins, see [1].
        '''

        x_fft = self.stft.process(self.target)

        idx = np.random.choice(
            x_fft.size,
            size=int(x_fft.size * self.trim_factor_artefacts),
            replace=False)

        row, col = np.unravel_index(idx, x_fft.shape)

        x_fft[row, col] = 0

        musical_noise = self.istft.process(x_fft)

        return musical_noise

    def artefacts_anchor(self):
        '''
        Artefacts anchor for a MUSHRA listening test.
        The anchor is defined as the sum of the target with musical
        noise; both equally loud. Musical noise is created by randomly
        zeroing 99% of the time-frequency bins, see [1].
        '''

        musical_noise = self.artefacts()

        # Loudness match the two
        target_loudness = self.ebur128.process(self.target).P
        noise_loudness = self.ebur128.process(musical_noise).P

        gain = utilities.conversion.db_to_amp(
            target_loudness - noise_loudness)

        anchor = self.target + gain * musical_noise
        anchor = anchor[:self.target.num_frames]

        return anchor.normalize()

    def quality_anchor(self):
        '''
        Quality anchor for a MUSHRA listening test.
        The anchor is defined as the sum of the distortion anchor,
        artefacts only and interferer only; all equally loud, see [2].
        '''

        target_loudness = -23
        signals = []

        for signal in [self.distorted_anchor(),
                       self.artefacts(),
                       self.interferer()]:

            loudness = self.ebur128.process(signal).P

            gain = utilities.conversion.db_to_amp(target_loudness - loudness)

            signal *= gain

            signals.append(signal)

        anchor = sum(signals)
        anchor = anchor[:self.target.num_frames]

        return anchor.normalize()

    def create(self):

        return Anchors(self.distorted_anchor(),
                       self.artefacts_anchor(),
                       self.inteference_anchor(),
                       self.quality_anchor())


if __name__ == '__main__':

    paths = [
        ('/vol/vssp/datasets/audio/DSD100/Sources/Test/019 - ',
         'James Elder & Mark M Thompson - The English Actor/vocals.wav'),
        ('/vol/vssp/datasets/audio/DSD100/Sources/Test/019 - ',
         'James Elder & Mark M Thompson - The English Actor/drums.wav'),
        ('/vol/vssp/datasets/audio/DSD100/Sources/Test/019 - ',
         'James Elder & Mark M Thompson - The English Actor/other.wav'),
        ('/vol/vssp/datasets/audio/DSD100/Sources/Test/019 - ',
         'James Elder & Mark M Thompson - The English Actor/bass.wav'),
    ]

    target = data.audio.Wave.read(paths[0]).as_mono()
    others = [data.audio.Wave.read(paths[1]).as_mono(),
              data.audio.Wave.read(paths[2]).as_mono(),
              data.audio.Wave.read(paths[3]).as_mono()]

    creator = Anchor(target, others)

    anchors = creator.create()

    for name in anchors._fields:
        wav = getattr(anchors, name)
        wav.write(name + '.wav')
